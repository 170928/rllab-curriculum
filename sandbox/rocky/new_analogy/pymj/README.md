# PyMj

PyMj is a set of Cython-based wrappers for Mujoco 1.40. It's written in a lightweight and unopinionated fashion to allow for the largest number of use cases:

* Low-level: using Cython header wrappers to write Cython code working directly with Mujoco data structures. Header wrappers can be found in `cymj/*.pxd`.

* Medium-level: using Python wrappers for Mujoco structures. These wrappers are lightweight Cython cdef classes that expose Mujoco runtime data to Python space. The data in the Mujoco structures is exposed to Python via NumPy arrays bound to Mujoco-allocated memory, so there is no copying overhead when accessing or modifying Mujoco state from Python. These wrappers can be found in `cymj/wrappers.pxi`. They're autogenerated from Mujoco header files by `scripts/gen_wrappers.py`.

* High-level: using Python wrappers `MjEnv` and `MjViewer`, designed to resemble the functionality of Gym's `MujocoEnv`. These Python wrappers are implemented on top of the aforementioned Cython struct wrappers. They can be found in the main module's `__init__.py`.

All Cython code (handwritten or generated) is in the `cymj` subpackage.

## Autogenerated wrappers

The Cython struct wrappers are generated by `scripts/gen_wrappers.py`. To illustrate how the wrappers work, let's consider a toy C structure and the corresponding generated Cython cdef class. Here's a stripped down version of `mjData` with a scalar member and a pointer (array) member:
```c
typedef struct _mjData {
    int ne;
    mjtNum* qpos;  // (nq x 1)
} mjData;
```
Here's the corresponding generated Cython wrapper code:
```cython
cdef class PyMjData(object):
    cdef mjData* ptr
    cdef mjModel* _model
    cdef np.ndarray _qpos

    cdef void _set(self, mjData* p, mjModel* model):
        self.ptr = p
        self._model = model
        self._qpos = _wrap_mjtNum_1d(p.qpos, model.nq)

    @property
    def ne(self): return self.ptr.ne

    @ne.setter
    def ne(self, int x): self.ptr.ne = x

    @property
    def qpos(self): return self._qpos

cdef PyMjData WrapMjData(mjData* p, mjModel* model):
    cdef PyMjData o = PyMjData()
    o._set(p, model)
    return o
```

`PyMjData` is the wrapper class for exposing the underlying Mujoco structure to Python; it doesn't perform any memory mangement. A user writing Cython code can create this wrapper using `WrapMjData`. A `mjModel` pointer must be passed because the shape of a `mjData` member, namely `qpos`, depends on `model->nq`.

Each field of `mjData` corresponds to some generated piece of code in `PyMjData` that depends on the type of that field. For example, `ne` is a scalar integer, so it gets exposed as a pair of getter and setter methods in `PyMjData`. `qpos` is an array represented as a pointer to its first element, so it's wrapped with a NumPy array by `_wrap_mjtNum_1d` and is exposed with a getter for that NumPy array.

The function `_wrap_mjtNum_1d` creates a Cython memoryview from the data pointer and converts it to a NumPy array pointing to the same memory:

```cython
cdef inline np.ndarray _wrap_mjtNum_1d(mjtNum* a, int shape0):
    if shape0 == 0: return None
    cdef mjtNum[:] b = <mjtNum[:shape0]> a
    return np.asarray(b)
```

Similar functions for other types are also generated as required.

Keep in mind that the only reason to use these autogenerated wrappers is to allow Python users of the Cython code to easily access Mujoco data (for instance the `MjSim` Cython class, found in `cymj/cymj.pyx`). If you're writing Cython code and you don't need the user to access Mujoco data from Python, then there is no reason to use these wrappers.



## Todo

- Some C types seem to be mapped incorrectly to Python types via the Cython-based memoryview-to-Numpy array conversion in the autogenerated wrappers. For example, `char` seems to be mapped onto the Numpy `int` type.
- Flesh out the viewer
- Use cimport everywhere in Cython code instead of include. Ensure that the Cython code defined by this package can be cimported elsewhere.
- Support for perturbations in MjSim
- Document MjSim and MjViewerContext
